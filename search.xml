<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《Libra R-CNN》论文笔记]]></title>
    <url>%2F2019%2F04%2F26%2F%E3%80%8ALibra-R-CNN%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CVPR2019 | Libra R-CNN: 全面平衡的目标检测器论文地址：https://arxiv.org/abs/1904.02701 代码地址：https://github.com/open-mmlab/mmdetection 主要贡献 IoU-balanced sampling：提升0.9个百分点 balanced feature pyramid：提升0.9个百分点 balanced L1 loss：提升0.8个百分点 实际项目中可参考！！ 研究动机目前主流的目标检测算法，无论 SSD、Faster R-CNN、Retinanet 这些的 detector 的设计其实都是三个步骤： 候选框采样 提取候选框特征 在标准多任务损失函数的指导下识别类别和修正位置 但是在以下三个方面存在不平衡： Sample level imbalance：在训练过程中，难例样本更有价值因为能提升检测性能。但是随机采样(random sampling)主要选中的是简单样本。OHEM会选择更多的难例样本，但是对噪音数据敏感，且引入额外花销。Focal loss在一阶段模型中效果不错，但是在两阶段效果一般因为两阶段模型已经过滤掉了大部分的容易负样本。如何选择具有代表性的region proposal？ Feature level imbalance：高层特征含有更多语义特征，低层特征含有更多位置特征。不同特征融合会产生更好效果。不同level的特征如何融合才能真正地充分利用？ Object level imbalance： 检测器有分类和定位两个任务。目前设计的损失函数能不能引导目标检测器更好地收敛？ 针对以上问题，作者提出了三个方面的改进： IoU-balanced sampling：通过IoU挖掘难例样本。 balanced feature pyramid balanced L1 loss 具体方法 IoU-balanced Sampling作者认为Sample level的不平衡是因为随机采样造成的，OHEM对噪音数据比较敏感。随机采样造成的不平衡见下图： 随机采样的话，70%以上的样本IoU不到0.05，因为一张图片中目标区域一般比较小，生成候选框时大部分候选框都是背景框，所以随机采样大部分样本集中在IoU不足0.05。事实上，60%的难例负样本的IoU都大于0.05， 随机采样只获得了30%。 假设要从M个候选框上采样N个负样本，随机采样下每个样本被选中的概率是： 通过根据IoU的值划分为K个区间，总数还为N，每个区间中的候选采样数为$M_k$, IoU-balanced sampling的公式为： Balanced Feature Pyramid 作者提出通过使用相同的集成平衡语义特征来增强多层特征。主要包括四个步骤： rescaling: 不同层l的特征表示为$C_l$。多层特征的数目表示为L。图4中C2拥有最高分辨率。将{C2,C3,C4,C5} resize到一个中间大小，例如C4，通过插值或者最大池化操作。 integrating：特征rescale后，童工平均得到balanced semantic feature。然后再通过相同的相反操作rescale。在这个过程中每个分辨率都从其他层获得了相同的信息。该过程是无参数的 refining：balanced的语义特征可以通过直接卷积或者non-local进一步refine。 strengthening：输出{P2,P3,P4,P5}用于检测 Balanced L1 LossFast R-CNN通过 multi-task loss来解决分类和定位问题，定义如下： $L_cls、L_loc$分别代表识别和定位的目标函数。p代表预测，u代表目标。$t^u$代表class u的回归结果，v代表回归目标。λ表示权重。loss大于等于1的样本称为outliers，其他称为inliers。 一个自然的想法是调节两个损失。然而，由于回归目标没有边界限制，直接增加定位损失的权重会使得模型对outlier更敏感。outliers看做是难例，产生过大的梯度会对训练过程带来损伤。inliers，是容易样本，相比outliers贡献的梯度很小，几乎只有outliers的30%。Smooth L1 loss的定义如下： 作者提出的Balanced L1 Loss： 梯度遵循： 这样|x|&lt;1的时候就会产生较大的梯度，即： 根据梯度求出： 同时满足： 结果如下图所示： 实验结果]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>Object Detection</tag>
        <tag>CVPR2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试复习]]></title>
    <url>%2F2019%2F04%2F25%2Fpython%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[常见python面试题Python是如何进行内存管理的？答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制 一、对象的引用计数机制 Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 1，一个对象分配一个新名称 2，将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 1，使用del语句对对象别名显示的销毁 2，引用超出作用域或被重新赋值 sys.getrefcount( )函数可以获得对象的当前引用计数 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。 二、垃圾回收 1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。 三、内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。 3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 1).对象的引用计数机制 Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 一个对象分配一个新名称 将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 使用del语句对对象别名显示的销毁 引用超出作用域或被重新赋值 2).垃圾回收 当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 3).内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统: Pymalloc机制：为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 什么是lambda函数？它有什么好处?答：lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数 1).lambda的用法： lambda是匿名函数，用法如下:lambda arg1,arg2..argN:expression using args 2).优点 lambda能和def做同样种类的工作，特别是对于那些逻辑简单的函数，直接用lambda会更简洁，而且省去取函数名的麻烦(给函数取名是个技术活) Python里面如何实现tuple和list的转换？答：直接使用tuple和list函数就行了，type()可以判断对象的类型 Python里面如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别）python中的变量只是一个标签，是引用 https://www.cnblogs.com/shenbuer/p/7977323.html 答：赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。 浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）浅拷贝就是里面的子对象还是共用，例如列表， 其他的复制一份新的 完全切片方法； 工厂函数，如list()； copy模块的copy()函数} 深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的deep.deepcopy()函数} 深拷贝就是全都复制新的 深拷贝中，对于非容易类型（如数字，字符串和其他‘原子’类型的对象）没有拷贝一说 python中可变对象和不可变对象 不可变对象包括int, float, long， str， tuple等 可变对象包括list，set， dict等 不可变指的是值的不可变， 对于不可变类型，如果要更改变量，则会创建一个新值，把变量绑定在新值上，而旧值如果没有被引用就等着被回收 函数值传递时，不可变对象传递是传值， 可变对象是传引用。因为可变对象，对象的操作不会重建对象，而不可变对象，每一次操作就操作新的对象 介绍一下except的用法和作用？答：try…except…except…[else…][finally…] 执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。 try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行 如果存在finally语句，最后总是会执行。 Python里面match()和search()的区别？re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。 re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值。 >&gt;&gt;print(re.match(‘super’, ‘superstition’).span()) (0, 5) >&gt;&gt;print(re.match(‘super’, ‘insuperable’)) None >&gt;&gt;print(re.search(‘super’, ‘superstition’).span()) (0, 5) >&gt;&gt;print(re.search(‘super’, ‘insuperable’).span()) (2, 7) Python里面如何生成随机数？ 随机整数：random.randint(a,b)：返回随机整数x,a&lt;=x&lt;=b random.randrange(start,stop,[,step])：返回一个范围在(start,stop,step)之间的随机整数，不包括结束值。 随机实数：random.random( ):返回0到1之间的浮点数 random.uniform(a,b):返回指定范围内的浮点数。 单引号，双引号，三引号的区别单引号和双引号是等效的，如果要换行，需要符号(),三引号则可以直接换行，并且可以包含注释 如果要表示Let’s go 这个字符串 单引号：s4 = ‘Let’s go’ 双引号：s5 = “Let’s go” s6 = ‘I realy like“python”!’ 这就是单引号和双引号都可以表示字符串的原因了 分别阐述3种引号用的场景和区别 1),单引号和双引号主要用来表示字符串 比如: 单引号:’python’ 双引号:”python” 2).三引号 三单引号:’’’python ‘’’,也可以表示字符串一般用来输入多行文本,或者用于大段的注释 三双引号：”””python”””，一般用在类里面,用来注释类,这样省的写文档,直接用类的对象doc访问获得文档 区别: 若你的字符串里面本身包含单引号,必须用双引号 比如: &quot;can&#39;t find the log\n&quot; Xrange和range的区别是什么？Xrange用于返回一个xrange对象，而range用于返回一个数组。不管那个范围多大，Xrange都使用同样的内存。 Python的参数传递是值传递还是引用传递举例说明Python函数参数传递的几种形式，并说明函数传参是值传递还是引用传递 1).Python的参数传递有： 位置参数 默认参数， 可变参数, 关键字参数 2).函数的传值到底是值传递还是引用传递，要分情况 a.不可变参数用值传递： 像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象 b.可变参数是用引用传递的 比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变. 字符串格式化:%和.format的区别字符串的format函数非常灵活，很强大,可以接受的参数不限个数，并且位置可以不按顺序，而且有较为强大的格式限定符(比如:填充，对齐,精度等) 代码会不会报错12list = ['a', 'b', 'c', 'd', 'e']print list[10:] 不会报错，而且会输出一个 []，并且不会导致一个 IndexError 解答: 当试图访问一个超过列表索引值的成员将导致 IndexError（比如访问以上列表的 list[10]）。尽管如此，试图访问一个列表的以超出列表长度数作为开始索引的切片将不会导致 IndexError，并且将仅仅返回一个空列表 一个讨厌的小问题是它会导致出现 bug ，并且这个问题是难以追踪的，因为它在运行时不会引发错误，吐血啊~~ 写出你认为最Pythonic的代码非Pythonic 12345temp = aa = bb = temppythonic:a,b=b,a 2).判断其值真假 123456789name = 'Tim'langs = ['AS3', 'Lua', 'C']info = &#123;'name': 'Tim', 'sex': 'Male', 'age':23 &#125; 非Pythonicif name != '' and len(langs) &gt; 0 and info != &#123;&#125;: print('All True!') pythonic:if name and langs and info: print('All True!') 3).列表推导式 1[x for x in range(1,100) if x%2**0] 4).zip创建键值对 123keys = ['Name', 'Sex', 'Age']values = ['Jack', 'Male', 23]dict(zip(keys,values)) pythonic的代码很多，这里举几个典型的例子 参考：https://github.com/taizilongxu/interview_python python关键字yield的作用是什么？为了理解yield有什么用,首先得理解generators,而理解generators前还要理解iterables Iterables当你创建了一个列表,你可以一个一个的读取它的每一项,这叫做iteration: 123456&gt;&gt;&gt; mylist = [1, 2, 3]&gt;&gt;&gt; for i in mylist:... print(i)123 Mylist是可迭代的.当你用列表推导式的时候,你就创建了一个列表,而这个列表也是可迭代的: 123456&gt;&gt;&gt; mylist = [x*x for x in range(3)]&gt;&gt;&gt; for i in mylist:... print(i)014 所有你可以用在for...in...语句中的都是可迭代的:比如lists,strings,files…因为这些可迭代的对象你可以随意的读取所以非常方便易用,但是你必须把它们的值放到内存里,当它们有很多值时就会消耗太多的内存. Generators生成器也是迭代器的一种,但是你只能迭代它们一次.原因很简单,因为它们不是全部存在内存里,它们只在要调用的时候在内存里生成: 123456&gt;&gt;&gt; mygenerator = (x*x for x in range(3))&gt;&gt;&gt; for i in mygenerator:... print(i)014 生成器和迭代器的区别就是用()代替[],还有你不能用for i in mygenerator第二次调用生成器:首先计算0,然后会在内存里丢掉0去计算1,直到计算完4. yieldYield的用法和关键字return差不多,下面的函数将会返回一个生成器: 12345678910111213&gt;&gt;&gt; def createGenerator():... mylist = range(3)... for i in mylist:... yield i*i...&gt;&gt;&gt; mygenerator = createGenerator() # 创建生成器&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!&lt;generator object createGenerator at 0xb7555c34&gt;&gt;&gt;&gt; for i in mygenerator:... print(i)014 在这里这个例子好像没什么用,不过当你的函数要返回一个非常大的集合并且你希望只读一次的话,那么它就非常的方便了. 要理解Yield你必须先理解当你调用函数的时候,函数里的代码并没有运行.函数仅仅返回生成器对象,这就是它最微妙的地方:-) 然后呢,每当for语句迭代生成器的时候你的代码才会运转. 现在,到了最难的部分: 当for语句第一次调用函数里返回的生成器对象,函数里的代码就开始运作,直到碰到yield,然后会返回本次循环的第一个返回值.所以下一次调用也将运行一次循环然后返回下一个值,直到没有值可以返回. 一旦函数运行并没有碰到yeild语句就认为生成器已经为空了.原因有可能是循环结束或者没有满足if/else之类的. python下划线命名的区别 首先是单下划线开头，这个被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数，如果使用 from a_module import * 导入时，这部分变量和函数不会被导入。不过值得注意的是，如果使用 import a_module 这样导入模块，仍然可以用 a_module._some_var 这样的形式访问到这样的对象。 在 Python 的官方推荐的代码样式中，还有一种单下划线结尾的样式，这在解析时并没有特别的含义，但通常用于和 Python 关键词区分开来，比如如果我们需要一个变量叫做 class，但 class 是 Python 的关键词，就可以以单下划线结尾写作 class_。 双下划线开头的命名形式在 Python 的类成员中使用表示名字改编 (Name Mangling)，即如果有一 Test 类里有一成员 __x，那么 dir(Test) 时会看到 _Test__x 而非 __x。这是为了避免该成员的名称与子类中的名称冲突。但要注意这要求该名称末尾没有下划线。 双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 __init__、__del__、__add__、__getitem__ 等，以及全局的 __file__、__name__ 等。 Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。 python迭代器和生成器的区别这里有个关于生成器的创建问题面试官有考： 问： 将列表生成式中[]改成() 之后数据结构是否改变？ 答案：是，从列表变为生成器 123456&gt;&gt;&gt; L = [x*x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x*x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000028F8B774200&gt; 通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator 迭代器是将所有的元素都一起放到内存，而生成器是遍历到的时候才放到内存中 ##Iterator 和 Iterable 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数： 这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 如何在一个函数里用全局变量?如果我在一个函数里建了一个全局变量,那么我怎么在另一个函数里使用这个全局变量? 我需要把这个全局变量赋值给这个函数的局部变量吗? 如果你要在别的函数里使用全局变量,只要在被调用全局变量函数的里事先用global声明一下: 1234567891011globvar = 0def set_globvar_to_one(): global globvar # 需要用global修饰一下globvar globvar = 1def print_globvar(): print globvar # 如果要读globbar的值的话不需要用global修饰set_globvar_to_one()print_globvar() # 输出 1 我猜正是因为全局变量比较危险,所以Python为了确保你真的知道它是全局变量,所以需要加一个global关键字. *args and **kwargs 位置参数： 就是普通的参数，x和n都是位置参数 123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 默认参数]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面试复习]]></title>
    <url>%2F2019%2F04%2F25%2FC%2B%2B%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.变量和常量的区别 变量在定义后为程序提供了一个有 名字的内存区域 常量不可以改变值，在定义的时候必须初始化。变量可以改变值，在定义的时候可以不进行初始化。 常量本身没有地址属性（除字符串常量等），变量有地址属性。 2.自增自减前操作和后操作的区别 ++a称为前操作，a++称为后操作。前操作是先加一，再返回值，后操作是先返回值，再加一。 3.指针的自增自减的区别 变量的自增自减是修改变量的值，指针的自增自减是修改指针的指向地址 4.变量 变量的主要意义有两点： 变量代表分配了一块存储区 变量代表这块存储区的名称 变量初始化的方式 复制初始化 int a = 200; 直接初始化 int a(100) 变量的定义和声明 声明的主要目的是表明变量的类型和名称，而定义的主要目的是为变量分配存储空间。 程序中变量可以被声明多次，但有且只有一个定义。 C++中的作用域 定义在所有函数外面的变量具有全局作用域 作用域分为全局作用域、局部作用域、语句作用域 变量有哪几种存储类型 存储类型是从变量的存在时间（即生存期）来划分变量。可分为静态存储方式和动态存储方式 动态存储变量，当程序运行到该变量处才为其分配存储空间，程序运行到变量所在作用域的结束处时自动回收其分配的存储空间。因此它的生存期即为所在作用域。 静态存储变量，当程序开始执行就为其分配存储空间，直到程序结束时，才收回变量的存储空间，其生命周期为整个程序执行的过程。 C++的存储类型有自动类型、寄存器类型、静态类型、外部类型。 auto，自动存储类型只能是局部变量，属于动态存储类型。 静态，static。即在程序运行的过程中静态变量始终是占用一个存储空间。使用局部静态变量是为了在下次调用该函数时，能使用上次调用后得到的该变量的值。 寄存器类型变量（register） 。属于动态存储类型，不为其分配内存，直接使用CPU的寄存器，以提高对这类变量的存取速度。 外部类型变量 。 外部类型变量必须是全局变量 ，在C++中，有两种情况使用外部类型变量。一种是在同一源程序文件下，当在全局的定义之前使用该变量时，在使用前要对该变量进行外部类型变量声明。另一种情况是当程序有多个文件组成时，若在一个源文件中要引用在另一个源文件中定义的全局变量，则必须外部声明。 如果在某文件中定义的全局变量不想被其他文件所调用，则必须将变量声明为静态全局变量。 引用 引用就是C++对象的另一个名字，在实际中引用主要用作函数的形式参数。通过在变量名前添加“&amp;”符号来定义。引用类型是一个 复合类型 ，指用其他类型定义的类型。每一种引用类型都关联到某一其他类型。C++不能定义引用类型的引用，但是可以定义任何其它类型的引用。 const引用和非const引用 const引用是指向const对象的引用。const引用必须被定义为const类型。const引用可以读取但是不可以修改引用对象，任何对const引用进行赋值都是不合法的，它适合指向const对象的引用。 输入流与输出流 C++的输入输出流是指由若干字节组成的字节序列，这些字节中数据按顺序从一个对象传送到另一个对象。在输入操作中，字节流从输入设备（如键盘、磁盘）流向内存；在输出操作时，字节流从内存流向输出设备（例如屏幕，打印机、磁盘）等。流中的内容可以是==ASCII字符、二进制形式的数据、图形图像、数字音频视频或其他形式的信息 。 实际上，在内存中为每个数据流开辟一个内存缓冲区，用来存放流中的数据。缓冲区中的数据就是流。 C++中的输入输出包括对标准输入设备键盘和标准输出设备显示器、对在外存磁盘上的文件和对内存中指定的字符串存储空间进行输入输出三个方面。 头文件是程序与类库的接口，iostream类库的接口分别由不同的头文件来实现。 如何重载输入输出 重载就是基于不同的参数表让同一个名称的函数定义不同的函数。 文件输入/输出 有三种流类对象可以用来处理文件，分别是ifstream、ofstream和fstream.ifstream表示可以读取的的文件流，ofstream表示可以写入的文件输出流，fstream表示可以读写的文件流。 异常和错误 异常就是程序运行时出现的不正常。例如，运行时耗尽了系统资源或遇到意外的非法输入。异常存在于程序的正常功能之外，并要求程序立即处理。 异常是程序错误处理的一部分。当程序代码检查到无法处理的时候，异常处理就会特别有用。在这些情况下，检测出问题的那部分程序需要一种方法把控制权转到可以处理这个问题的那部分程序。错误检测程序还必须指出具体出现了什么问题，而且可能需要提供一些附加信息。 异常处理的方法包括两个方面： throw表达式，错误检测部分使用这种表达式说明遇到了不可处理的错误。throw引发了异常条件。 try块，错误处理部分使用它来处理异常。try语句块以try关键字开始，并以一个或多个catch子句结束。在try块中执行的代码所抛出(throw)的异常 预处理和内存管理 预处理是指在进行编译的第一遍扫描之前所做的工作。 预处理由预处理程序负责完成。当对一个源文件进行编译时，系统将自动引用预处理程序对源程序中的预处理部分做处理，处理完毕自动进入对源程序的编译。 宏定义又称为宏代换，宏替换，简称宏。作用就是可以自动产生代码 C语言中有三种预处理功能： 宏定义。语法为:#define&lt;标识符&gt;&lt;字符串&gt;，其中的标识符就是所谓的符号常量，也称为“宏名”。 预处理（预编译）工作也叫做宏展开，即将宏名替换为字符串 。带参数的宏定义格式为：#define&lt;宏名&gt;(&lt;参数表&gt;)&lt;宏体&gt;.&lt;宏体&gt;是被替换用的字符串，宏体中的字符串是由参数表中的各个参数组成的表达式。 宏定义和操作符的区别：宏定义是替换，不做计算，也不做表达式求解。另外，宏的替换是在编译前进行，所以不占用内存和编译时间。 文件包含 条件编译 宏展开实际上就是用宏定义时设计的宏体去代替宏指令名，并且用实际参数一一取代形式参数。 include的使用方式 include指示只接受一个参数就是头文件名。预处理器用指定的头文件内容替代每个#include. 使用方式有#include&lt;&gt;和#include””两种 include&lt;&gt;是使用标准头文件。标准头文件是在系统文件目录下查找。 include“”是使用自定义头文件。用户自定义文件会依次在用户目录、C++安装目录和系统文件中查找。 预处理的使用123#define DEBUG#ifdef DEBUG#endif 判断DEBUG是否被定义了，如果被定义了，就进行…操作 const的使用 const int *，是用修饰指针所指向的变量，即指针指向为常量，就是不能修改该指针指向的变量的值 int const，const在int 的右侧，修饰指针本身，即指针本身为常量。就是不能修改指针的指向，但是可以修改指针指向的内容 const int * const 不仅指针本身不能修改，指向的内容也不能修改。 const与#define的特点和区别 define只是用来做本文替换的，例如表示的是编译器进行编译的时候，编译器首先把所有的PI替换，然后进行遍历。存在于程序的代码段，在实际程序中只是一个常数，并没有实际的存在。 1#define PI 3.14 const常量存在于程序的数据段，并在堆栈分配了空间。const常量是一个Run-Time的概念，在程序中确实存在并可以被调用、传递。 const的作用 定义常量，定义的乘凉编译器可以对其进行数据静态类型安全检查 修饰函数形式参数：当输入参数为用户自定义类型和抽象数据类型时，应该将值传递改为”const&amp;传递”，可以提高效率 修饰函数的返回值。 修饰类的成员函数：任何不会修改数据成员的函数都应用const修饰，这样当不小心修改了数据成员或者调用了非const成员函数的时候，编译器都会报错。 static的作用 在函数体，一个被声明为静态的变量在这一函数被调用的过程中维持其值不变。 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所有函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。 在模块内，一个被声明为静态的函数只可被这一模块内的其他函数调用。那就是这个函数被限制在声明它的模块的本地范围内使用。 static 全局变量和普通的全局变量的区别 全局变量加上static就是 静态的全局变量 ，全局变量本身就是静态存储方式，全局静态变量也是静态存储方式，这两者存储方式相同。 区别是非静态全局变量的作用域是 整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的 。而静态全局变量限制了作用域为只在定义该变量的源文件内有效，在其他源文件中不能使用。 把局部变量变为静态变量改变的是存储方式，即改变了它的生存期；吧全局变量改变为静态变量是改变的作用域。 static全局变量和普通全局变量的区别是，static全局变量只初始化一次，防止在其他文件单元中被引用。 static局部变量和普通局部变量的区别是，static局部变量只被初始化一次，下一次依据上一次结果值 static函数和普通函数的区别是，static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品 sizeof123456789101112char str[] = "Hello";char *p = str;int n = 10;sizeof(str) = 6sizeof(p) = 4;sizeof(n) = 4;void Func(char str[100])&#123; sizeof(str) = 4;&#125;void *p = malloc(100);sizeof(p) = 4 如果数组变量被传入函数中做sizeof运算，则和指针的运算没有区别，否则得到整个数组占用内存的总大小。对于指针，无论是什么类型，都是4. 普通函数不占用内存，只要有虚函数，就会占用一个指针大小的内存，原因是系统多用了一个指针维护这个类的虚函数表，而且无论类中含有多少个虚函数，都不会再影响类的大小。 如果一个类是空的，编译器会安插一个char给空类，用来标记它的每一个对象。如果一个类虚继承另一个类，则需要维护一个指向负类的指针，如果虚继承多个父类，则1维护多个指针。 sizeof与strlen区别 sizeof是操作符，strlen是函数 sizeof操作符的结果类型是size_t，即unsign dint类型，该类型保证能容纳实现所建立的最大对象的字节大小。 sizeof可以用类型做参数，strlen只能用char*作参数，且必须是以”\0”结尾的 sizeof在编译的时候就被计算过了，strlen的结果要在运行的时候才能计算 在计算字符串数组的长度上有区别，sizeof计算字符串时会加上结束符’\0\,而 strlen则不会。 123char str[20] = "0123456789"int a = strlen(str) //10int b = sizeof(str) // 20 a 计算的是以0x00结束的字符串的长度（不包括0x00），结果为10b计算的是分配数组的所占内存的大小，不瘦里面存储内容的改变而改变，是20123char *ss = "0123456789"int a = strlen(ss) //10int b = sizeof(ss) // 4 b计算的是指针所占的内存空间大小。 sizeof的作用 查看某个类型的对象在内存中所占的单元字节。 在动态分配一对象时，可以让系统知道要分配多少内存。 内联函数 宏定义使用预处理器实现，没有了参数压栈，代码生成等操作，效率很高。但是不能进行参数有效性的检测，不能享受C++编译器演个类型检查的好处。 指针和引用的区别 初始化要求不同。引用在创建的同事必须初始化，即引用到一个有效的对象；指针在定义的时候不必初始化，可以再定义后面的任何地方重新赋值。 可修改性不同。引用一旦被初始化为指向一个对象，它就不能改变为另一个对象的引用；而指针在任何时候都可以改变为指向另一个对象。 不存在NULL引用，引用必须指向某个对象。指针则可以是NULL，不需要总是指向某些对象，可以把指针指向任意的对象，指针更加灵活，也容易出错。 总的来说，引用即具有指针的效率，又具有变量使用的方便性和直观性。 指针加减操作1int a[5] = &#123;1，2，3，4，5&#125;； a与&amp;a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址；&amp;a是对象（数组）首地址，a+1是数组下一元素的地址,即a[1];而&amp;a+1是下一个对象的地址，即a[5] 指针比较12345678char str1[] = "abc";char str2[] = "abc";const char str3[] = "abc";const char str4[] = "abc";const char* str5 = "abc";const char* str6 = "abc";char* str7 = "abc";char* str8 = "abc" 数组str1,str2,str3,str4都是在栈中分配的，内存中内容都为”abc”加一个’0’，但是它们的位置不同，所以都不相等数组5，6，7，8也是在栈中分配的，它们指向“abc”字符串，此时”abc”存放在数据区，所以它们指向同一块数据区的内存。 12char* str2 = "AAA"str2[0] = 'B'; 是错误的，因为str2指向的是字符串常量，常量不能修改。 指针常量和常量指针 前面的一个通常是修饰部分，中心词是后面一个词。 常量指针，表述为是常量的指针，它首先应该是一个指针。它是指向常量的指针，指针所指向的地址的内容是不可修改的。 指针常量，表述为是指针的常量，它首先是一个常量。指针常量就是不能修改指针所指向的地址，一开始初始化指向哪，它就只能指向哪。 就像一个数组的数组名一样，是一个固定的指针，不能对它移动操作。 指针的区别1234char * const p1;char const * p2;const char *p3;const char * const p4; 如果const位于*号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量 ==const位于*的右侧，const就是修饰指针本身，即指针本身是常量 this指针 类的非静态成员函数才有this指针 对于类成员函数来说，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。当程序被编译之后，此成员函数地址即已确定。一个类的成员函数体只有一份，而成员函数之所以能把属于此类的各个对象的数据区分开，就在于每次执行类成员函数的时候，把当前对象的this指针（对象首地址）传入。如果没有访问对象的任何数据成员，特征和全局函数并没有太大的区别。 指针数组和数组指针的区别 指针数组是指一个数组里存放的都是同一个类型的指针，如int * a[10]; 数组指针指一个指向一维或者多维数组的指针，例如int * b = new int[10]; 函数指针和指针函数的区别 指针函数是指带指针的函数，即本质是一个函数，并且返回类型是某一类型的指针，其定义为下：返回类型标识符 *返回名称(形式参数表){函数体} 函数指针是指向函数的指针变量，因而它本身首先应该是指针变量，只不过该指针变量指向函数。有了指向函数的指针变量后，可用该指针变量调用函数。 各种指针的定义 void (*f)(int, int)，f是指向void max(int x, int y)类型的函数指针 int *fn()，fn是返回int指针类型的函数 const int *p,p是一个指向const的指针，指向一个常量 int * const q, q是一个const指针 const int* const ptr，ptr是指向const的const指针 野指针 ”野指针“不是NULL指针，而是指向”垃圾“内存的指针，人们一般不会错用NULL指针，野指针的成因主要有两种： 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针p被free或者delete后，没有置为NULL，让人误以为p是合法的指针。 malloc/free和new/delete的区别 malloc与free是C++/C的标准库函数，new/delete是C++的运算符。它们都可以用于申请动态内存和释放内存 对于非内部数据类型的对象而言，光用malloc无法满足动态对象的要求，对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内。因此需要能完成动态内存分配和初始化工作的运算new，以及一个能完成清理与释放内存工作的运算符delete 内存的分配方式 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，例如全局变量。 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放，处理器的指令集中关于栈内存的分配运算，因此效率很高，但是分配的内存容量有限。 从堆上分配，也称动态内存分配。程序运行的时候用malloc或者new申请任意多少的内存，程序员自己负责在合适用free或者delete释放内存。 类的特性抽象、继承、封装、重载、多态 静态成员变量 静态成员变量被当做该类类型的全局变量。对于非静态成员，每个类对象都有自己的复制品，而静态成员对每个类的类型只有一个复制品。静态成员只有一份，由该类类型的所有对象共享访问。 静态数据成员必须在类外面初始化，不受private的作用，可以直接用类名调用。 构造函数和析构函数的重载 构造函数可以被重载，因为构造函数可以有多个，且可以带参数 析构函数不可以被重载。只有一个，且不能带参数 重载和覆写的区别 重载是指子类改写了父类的方法 重载编写一个与已有函数同名但是参数表不同（参数数量或参数类型不同）的方法 方法名必须相同 参数列表必须不相同，与参数列表的顺序无关。 返回值类型可以不相同 覆写是指同一个函数不同版本之间参数不同。覆写是派生类重写基类的虚函数 只有虚函数和抽象方法才能被覆写 相同的函数名 相同的参数列表 相同的返回值类型 C++类继承的三种关系C++中继承主要有三种关系：public、protected和private public继承是一种接口继承，子类可以完全代替负类完成父类接口所声明的行为。如果父类中的某个函数是public的，那么在被子类继承后仍然是public的 protected继承是一种实现继承，子类不能代替父类完成父类接口所声明的行为，此时子类不能自动转换成负类的接口。protected继承会将负类中的public可见性的成员修改为protected可见性。 private继承是一种实现继承。子类不能代替父类完成父类接口所声明的行为，此时子类不能自动转换成为父类的接口。父类的public和protected都被子类修改成为private可见性。 什么是多态 多态性的定义：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行效果。有两种类型的多态性： 编译时的多态 。编译时的多态是通过重载来实现的。对于非虚的成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现何种操作。 运行时的多态 。运行时的多态是指直到系统运行时，才根据实际情况决定实现何种操作。C++中，运行时的多态 虚函数的实现 虚函数是通过 虚函数表 来实现的。一个类中含有虚函数，则系统会为这个类分配一个指针成员指向一张虚函数表(vtbl)，表中每一项指向一个虚函数的地址，实现上就是一个函数指针的数组。 虚函数是为了允许用基类的指针来调用子类的这个函数 当一个成员函数被声明为虚函数后，其派生类的同名函数都自动成为虚函数，派生类的该虚函数，可以不加virtual 在构造函数中，虚拟机制机制不会发生作用。 多重继承 优点：对象可以调用多个基类中的接口。 缺点：容易出现继承向上的二义性。 为什么要引入抽象基类和纯虚函数 纯虚函数在基类中是没有定义的，必须在子类中加以实现，很想Java中的接口。如果一个基类中含有一个或多个纯虚函数，那么它就属于抽象基类，不能被实例化。 引入抽象基类和纯虚函数的原因： 为了方便使用多态特性 抽象基类不能被实例化，它定义的纯虚函数相当于接口，能把派生类的共同行为提取出来。 虚函数与纯虚函数的区别 类里如果生命了虚函数，这个函数是实现的，哪怕是空实现，作用是为了能让这个函数在它的子类里覆盖。纯虚函数只是一个接口，是个函数的声明 虚函数在子类里可以不重载，但纯虚函数必须在子类中实现。 带纯虚函数的类叫做抽象基类，不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。 指针形参与引用形参的区别 函数的形参可以是指针，此时将复制实参指针。被复制的指针只影响对指针的赋值。如果函数形参是非const类型的，则函数可以通过指针实现赋值，修改指针所指向对象的值。 指针形参是指函数的参数是指针，它不会像引用形参那样通过函数调用影响实参的值，但是调用后它会修改实参的独享。 STL容器分类 STL序列容器： vector string deque list STL关联容器 set multiset map multimap STL适配容器 stack queue priority_queue 函数模板 函数模板技术定义了参数化的非成员函数，这使得程序能够使用不同的参数类型调用相同的函数。而至于使用何种类型，则是由编译器确定并从模板中生成相应类型的代码。编译器确定了模板函数的实际类型参数，称之为模板的实例化。 类模板类模板描述了能够管理其他数据类型的通用数据类型。类模板技术通常用于建立包含其他类型的容器类。 STL如何实现vector vector支持随机访问，内部使用动态数组的方式实现。当进行insert或者push_back等增加元素的操作时，如果此时动态数组的内存不够用，就要动态地重新分配，一般是当前大小的两倍，然后吧原数组的内容拷贝过去。 vector的size()和capacity()是不同的，前者表示数组中元素的多少，后者表示数组有多大的容量。 vector的内部使用allocator类进行内存管理，程序员不需要自己操作内存。 vector中vector::size_type 十个unsigned int类型成员。无符号的整数是大于等于0的，循环条件应该使用i &gt; 0作为循环条件，i为0时结束循环 list和vector的区别 vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好地支持随机存取（使用[]操作符访问其中的元素）。当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。 list是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。如果需要大量的插入和删除，而不关心随机存取，则应使用list。 适配器stack和queue的使用12stack&lt;int,vector&lt;int&gt;&gt; s;queue&lt;int, vector&lt;int&gt;&gt; q; queue是先进先出的，入队（调用push）是对队尾进行操作，由于q使用vector作为其序列容器，因此实际调用的是vector的push_back成员函数。而出队(调用pop)是对队首进行操作，此时q需要调用的是vector的pop_front成员函数，而vector没有这个函数 map的用法1234567891011121314map&lt;int, string&gt; mapstring;mapstring.insert(pair&lt;int, string&gt;(1, "one"));mapstring[1] = "one one";mapstring.erase(2);map&lt;int, string&gt;::iterator it = mapstring.find(2);if(f != mapstring.end())&#123; mapstring.erase(f);&#125;map&lt;int, string&gt;::iterator it = mapstring.begin();while(it != mapstring.end())&#123; cout&lt;&lt;(*it).first &lt;&lt; (*it).second&#125; STL中map内部是如何实现的 标准的STL关联容器(包括set，map以及multiset和map)内部结构都是一个平航二叉树，平衡二叉树包括 AVL-tree RB-tree AA-tree STL的底层机制都是以红黑树完成的。红黑树是一个独立容器，但并不给外界使用。平均和最坏情况下的插入、删除、查找时间都是O(lgn) 红黑树的属性 节点为红色或者黑色 所有叶子节点都是空节点，并且为黑色 如果父节点是红色的，那么两个子节点都是黑色的 节点到其子孙节点的每条简单路径上都包含相同数目的黑色节点 根节点是黑色的 map和hashmap的区别 底层数据结构不同，map是红黑树，hashmap是哈希表 map的优点在于元素可以自动按照键值排序,而hashmap的优点在于它的各项操作的平均时间复杂度接近常数]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
