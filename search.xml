<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++面试复习]]></title>
    <url>%2F2019%2F04%2F25%2FC%2B%2B%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.变量和常量的区别 变量在定义后为程序提供了一个有 名字的内存区域 常量不可以改变值，在定义的时候必须初始化。变量可以改变值，在定义的时候可以不进行初始化。 常量本身没有地址属性（除字符串常量等），变量有地址属性。 2.自增自减前操作和后操作的区别 ++a称为前操作，a++称为后操作。前操作是先加一，再返回值，后操作是先返回值，再加一。 3.指针的自增自减的区别 变量的自增自减是修改变量的值，指针的自增自减是修改指针的指向地址 4.变量 变量的主要意义有两点： 变量代表分配了一块存储区 变量代表这块存储区的名称 变量初始化的方式 复制初始化 int a = 200; 直接初始化 int a(100) 变量的定义和声明 声明的主要目的是表明变量的类型和名称，而定义的主要目的是为变量分配存储空间。 程序中变量可以被声明多次，但有且只有一个定义。 C++中的作用域 定义在所有函数外面的变量具有全局作用域 作用域分为全局作用域、局部作用域、语句作用域 变量有哪几种存储类型 存储类型是从变量的存在时间（即生存期）来划分变量。可分为静态存储方式和动态存储方式 动态存储变量，当程序运行到该变量处才为其分配存储空间，程序运行到变量所在作用域的结束处时自动回收其分配的存储空间。因此它的生存期即为所在作用域。 静态存储变量，当程序开始执行就为其分配存储空间，直到程序结束时，才收回变量的存储空间，其生命周期为整个程序执行的过程。 C++的存储类型有自动类型、寄存器类型、静态类型、外部类型。 auto，自动存储类型只能是局部变量，属于动态存储类型。 静态，static。即在程序运行的过程中静态变量始终是占用一个存储空间。使用局部静态变量是为了在下次调用该函数时，能使用上次调用后得到的该变量的值。 寄存器类型变量（register） 。属于动态存储类型，不为其分配内存，直接使用CPU的寄存器，以提高对这类变量的存取速度。 外部类型变量 。 外部类型变量必须是全局变量 ，在C++中，有两种情况使用外部类型变量。一种是在同一源程序文件下，当在全局的定义之前使用该变量时，在使用前要对该变量进行外部类型变量声明。另一种情况是当程序有多个文件组成时，若在一个源文件中要引用在另一个源文件中定义的全局变量，则必须外部声明。 如果在某文件中定义的全局变量不想被其他文件所调用，则必须将变量声明为静态全局变量。 引用 引用就是C++对象的另一个名字，在实际中引用主要用作函数的形式参数。通过在变量名前添加“&amp;”符号来定义。引用类型是一个 复合类型 ，指用其他类型定义的类型。每一种引用类型都关联到某一其他类型。C++不能定义引用类型的引用，但是可以定义任何其它类型的引用。 const引用和非const引用 const引用是指向const对象的引用。const引用必须被定义为const类型。const引用可以读取但是不可以修改引用对象，任何对const引用进行赋值都是不合法的，它适合指向const对象的引用。 输入流与输出流 C++的输入输出流是指由若干字节组成的字节序列，这些字节中数据按顺序从一个对象传送到另一个对象。在输入操作中，字节流从输入设备（如键盘、磁盘）流向内存；在输出操作时，字节流从内存流向输出设备（例如屏幕，打印机、磁盘）等。流中的内容可以是==ASCII字符、二进制形式的数据、图形图像、数字音频视频或其他形式的信息 。 实际上，在内存中为每个数据流开辟一个内存缓冲区，用来存放流中的数据。缓冲区中的数据就是流。 C++中的输入输出包括对标准输入设备键盘和标准输出设备显示器、对在外存磁盘上的文件和对内存中指定的字符串存储空间进行输入输出三个方面。 头文件是程序与类库的接口，iostream类库的接口分别由不同的头文件来实现。 如何重载输入输出 重载就是基于不同的参数表让同一个名称的函数定义不同的函数。 文件输入/输出 有三种流类对象可以用来处理文件，分别是ifstream、ofstream和fstream.ifstream表示可以读取的的文件流，ofstream表示可以写入的文件输出流，fstream表示可以读写的文件流。 异常和错误 异常就是程序运行时出现的不正常。例如，运行时耗尽了系统资源或遇到意外的非法输入。异常存在于程序的正常功能之外，并要求程序立即处理。 异常是程序错误处理的一部分。当程序代码检查到无法处理的时候，异常处理就会特别有用。在这些情况下，检测出问题的那部分程序需要一种方法把控制权转到可以处理这个问题的那部分程序。错误检测程序还必须指出具体出现了什么问题，而且可能需要提供一些附加信息。 异常处理的方法包括两个方面： throw表达式，错误检测部分使用这种表达式说明遇到了不可处理的错误。throw引发了异常条件。 try块，错误处理部分使用它来处理异常。try语句块以try关键字开始，并以一个或多个catch子句结束。在try块中执行的代码所抛出(throw)的异常 预处理和内存管理 预处理是指在进行编译的第一遍扫描之前所做的工作。 预处理由预处理程序负责完成。当对一个源文件进行编译时，系统将自动引用预处理程序对源程序中的预处理部分做处理，处理完毕自动进入对源程序的编译。 宏定义又称为宏代换，宏替换，简称宏。作用就是可以自动产生代码 C语言中有三种预处理功能： 宏定义。语法为:#define&lt;标识符&gt;&lt;字符串&gt;，其中的标识符就是所谓的符号常量，也称为“宏名”。 预处理（预编译）工作也叫做宏展开，即将宏名替换为字符串 。带参数的宏定义格式为：#define&lt;宏名&gt;(&lt;参数表&gt;)&lt;宏体&gt;.&lt;宏体&gt;是被替换用的字符串，宏体中的字符串是由参数表中的各个参数组成的表达式。 宏定义和操作符的区别：宏定义是替换，不做计算，也不做表达式求解。另外，宏的替换是在编译前进行，所以不占用内存和编译时间。 文件包含 条件编译 宏展开实际上就是用宏定义时设计的宏体去代替宏指令名，并且用实际参数一一取代形式参数。 include的使用方式 include指示只接受一个参数就是头文件名。预处理器用指定的头文件内容替代每个#include. 使用方式有#include&lt;&gt;和#include””两种 include&lt;&gt;是使用标准头文件。标准头文件是在系统文件目录下查找。 include“”是使用自定义头文件。用户自定义文件会依次在用户目录、C++安装目录和系统文件中查找。 预处理的使用123#define DEBUG#ifdef DEBUG#endif 判断DEBUG是否被定义了，如果被定义了，就进行…操作 const的使用 const int *，是用修饰指针所指向的变量，即指针指向为常量，就是不能修改该指针指向的变量的值 int const，const在int 的右侧，修饰指针本身，即指针本身为常量。就是不能修改指针的指向，但是可以修改指针指向的内容 const int * const 不仅指针本身不能修改，指向的内容也不能修改。 const与#define的特点和区别 define只是用来做本文替换的，例如表示的是编译器进行编译的时候，编译器首先把所有的PI替换，然后进行遍历。存在于程序的代码段，在实际程序中只是一个常数，并没有实际的存在。 1#define PI 3.14 const常量存在于程序的数据段，并在堆栈分配了空间。const常量是一个Run-Time的概念，在程序中确实存在并可以被调用、传递。 const的作用 定义常量，定义的乘凉编译器可以对其进行数据静态类型安全检查 修饰函数形式参数：当输入参数为用户自定义类型和抽象数据类型时，应该将值传递改为”const&amp;传递”，可以提高效率 修饰函数的返回值。 修饰类的成员函数：任何不会修改数据成员的函数都应用const修饰，这样当不小心修改了数据成员或者调用了非const成员函数的时候，编译器都会报错。 static的作用 在函数体，一个被声明为静态的变量在这一函数被调用的过程中维持其值不变。 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所有函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。 在模块内，一个被声明为静态的函数只可被这一模块内的其他函数调用。那就是这个函数被限制在声明它的模块的本地范围内使用。 static 全局变量和普通的全局变量的区别 全局变量加上static就是 静态的全局变量 ，全局变量本身就是静态存储方式，全局静态变量也是静态存储方式，这两者存储方式相同。 区别是非静态全局变量的作用域是 整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的 。而静态全局变量限制了作用域为只在定义该变量的源文件内有效，在其他源文件中不能使用。 把局部变量变为静态变量改变的是存储方式，即改变了它的生存期；吧全局变量改变为静态变量是改变的作用域。 static全局变量和普通全局变量的区别是，static全局变量只初始化一次，防止在其他文件单元中被引用。 static局部变量和普通局部变量的区别是，static局部变量只被初始化一次，下一次依据上一次结果值 static函数和普通函数的区别是，static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品 sizeof123456789101112char str[] = "Hello";char *p = str;int n = 10;sizeof(str) = 6sizeof(p) = 4;sizeof(n) = 4;void Func(char str[100])&#123; sizeof(str) = 4;&#125;void *p = malloc(100);sizeof(p) = 4 如果数组变量被传入函数中做sizeof运算，则和指针的运算没有区别，否则得到整个数组占用内存的总大小。对于指针，无论是什么类型，都是4. 普通函数不占用内存，只要有虚函数，就会占用一个指针大小的内存，原因是系统多用了一个指针维护这个类的虚函数表，而且无论类中含有多少个虚函数，都不会再影响类的大小。 如果一个类是空的，编译器会安插一个char给空类，用来标记它的每一个对象。如果一个类虚继承另一个类，则需要维护一个指向负类的指针，如果虚继承多个父类，则1维护多个指针。 sizeof与strlen区别 sizeof是操作符，strlen是函数 sizeof操作符的结果类型是size_t，即unsign dint类型，该类型保证能容纳实现所建立的最大对象的字节大小。 sizeof可以用类型做参数，strlen只能用char*作参数，且必须是以”\0”结尾的 sizeof在编译的时候就被计算过了，strlen的结果要在运行的时候才能计算 在计算字符串数组的长度上有区别，sizeof计算字符串时会加上结束符’\0\,而 strlen则不会。 123char str[20] = "0123456789"int a = strlen(str) //10int b = sizeof(str) // 20 a 计算的是以0x00结束的字符串的长度（不包括0x00），结果为10b计算的是分配数组的所占内存的大小，不瘦里面存储内容的改变而改变，是20123char *ss = "0123456789"int a = strlen(ss) //10int b = sizeof(ss) // 4 b计算的是指针所占的内存空间大小。 sizeof的作用 查看某个类型的对象在内存中所占的单元字节。 在动态分配一对象时，可以让系统知道要分配多少内存。 内联函数 宏定义使用预处理器实现，没有了参数压栈，代码生成等操作，效率很高。但是不能进行参数有效性的检测，不能享受C++编译器演个类型检查的好处。 指针和引用的区别 初始化要求不同。引用在创建的同事必须初始化，即引用到一个有效的对象；指针在定义的时候不必初始化，可以再定义后面的任何地方重新赋值。 可修改性不同。引用一旦被初始化为指向一个对象，它就不能改变为另一个对象的引用；而指针在任何时候都可以改变为指向另一个对象。 不存在NULL引用，引用必须指向某个对象。指针则可以是NULL，不需要总是指向某些对象，可以把指针指向任意的对象，指针更加灵活，也容易出错。 总的来说，引用即具有指针的效率，又具有变量使用的方便性和直观性。 指针加减操作1int a[5] = &#123;1，2，3，4，5&#125;； a与&amp;a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址；&amp;a是对象（数组）首地址，a+1是数组下一元素的地址,即a[1];而&amp;a+1是下一个对象的地址，即a[5] 指针比较12345678char str1[] = "abc";char str2[] = "abc";const char str3[] = "abc";const char str4[] = "abc";const char* str5 = "abc";const char* str6 = "abc";char* str7 = "abc";char* str8 = "abc" 数组str1,str2,str3,str4都是在栈中分配的，内存中内容都为”abc”加一个’0’，但是它们的位置不同，所以都不相等数组5，6，7，8也是在栈中分配的，它们指向“abc”字符串，此时”abc”存放在数据区，所以它们指向同一块数据区的内存。 12char* str2 = "AAA"str2[0] = 'B'; 是错误的，因为str2指向的是字符串常量，常量不能修改。 指针常量和常量指针 前面的一个通常是修饰部分，中心词是后面一个词。 常量指针，表述为是常量的指针，它首先应该是一个指针。它是指向常量的指针，指针所指向的地址的内容是不可修改的。 指针常量，表述为是指针的常量，它首先是一个常量。指针常量就是不能修改指针所指向的地址，一开始初始化指向哪，它就只能指向哪。 就像一个数组的数组名一样，是一个固定的指针，不能对它移动操作。 指针的区别1234char * const p1;char const * p2;const char *p3;const char * const p4; 如果const位于*号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量 ==const位于*的右侧，const就是修饰指针本身，即指针本身是常量 this指针 类的非静态成员函数才有this指针 对于类成员函数来说，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。当程序被编译之后，此成员函数地址即已确定。一个类的成员函数体只有一份，而成员函数之所以能把属于此类的各个对象的数据区分开，就在于每次执行类成员函数的时候，把当前对象的this指针（对象首地址）传入。如果没有访问对象的任何数据成员，特征和全局函数并没有太大的区别。 指针数组和数组指针的区别 指针数组是指一个数组里存放的都是同一个类型的指针，如int * a[10]; 数组指针指一个指向一维或者多维数组的指针，例如int * b = new int[10]; 函数指针和指针函数的区别 指针函数是指带指针的函数，即本质是一个函数，并且返回类型是某一类型的指针，其定义为下：返回类型标识符 *返回名称(形式参数表){函数体} 函数指针是指向函数的指针变量，因而它本身首先应该是指针变量，只不过该指针变量指向函数。有了指向函数的指针变量后，可用该指针变量调用函数。 各种指针的定义 void (*f)(int, int)，f是指向void max(int x, int y)类型的函数指针 int *fn()，fn是返回int指针类型的函数 const int *p,p是一个指向const的指针，指向一个常量 int * const q, q是一个const指针 const int* const ptr，ptr是指向const的const指针 野指针 ”野指针“不是NULL指针，而是指向”垃圾“内存的指针，人们一般不会错用NULL指针，野指针的成因主要有两种： 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针p被free或者delete后，没有置为NULL，让人误以为p是合法的指针。 malloc/free和new/delete的区别 malloc与free是C++/C的标准库函数，new/delete是C++的运算符。它们都可以用于申请动态内存和释放内存 对于非内部数据类型的对象而言，光用malloc无法满足动态对象的要求，对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内。因此需要能完成动态内存分配和初始化工作的运算new，以及一个能完成清理与释放内存工作的运算符delete 内存的分配方式 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，例如全局变量。 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放，处理器的指令集中关于栈内存的分配运算，因此效率很高，但是分配的内存容量有限。 从堆上分配，也称动态内存分配。程序运行的时候用malloc或者new申请任意多少的内存，程序员自己负责在合适用free或者delete释放内存。 类的特性抽象、继承、封装、重载、多态 静态成员变量 静态成员变量被当做该类类型的全局变量。对于非静态成员，每个类对象都有自己的复制品，而静态成员对每个类的类型只有一个复制品。静态成员只有一份，由该类类型的所有对象共享访问。 静态数据成员必须在类外面初始化，不受private的作用，可以直接用类名调用。 构造函数和析构函数的重载 构造函数可以被重载，因为构造函数可以有多个，且可以带参数 析构函数不可以被重载。只有一个，且不能带参数 重载和覆写的区别 重载是指子类改写了父类的方法 重载编写一个与已有函数同名但是参数表不同（参数数量或参数类型不同）的方法 方法名必须相同 参数列表必须不相同，与参数列表的顺序无关。 返回值类型可以不相同 覆写是指同一个函数不同版本之间参数不同。覆写是派生类重写基类的虚函数 只有虚函数和抽象方法才能被覆写 相同的函数名 相同的参数列表 相同的返回值类型 C++类继承的三种关系C++中继承主要有三种关系：public、protected和private public继承是一种接口继承，子类可以完全代替负类完成父类接口所声明的行为。如果父类中的某个函数是public的，那么在被子类继承后仍然是public的 protected继承是一种实现继承，子类不能代替父类完成父类接口所声明的行为，此时子类不能自动转换成负类的接口。protected继承会将负类中的public可见性的成员修改为protected可见性。 private继承是一种实现继承。子类不能代替父类完成父类接口所声明的行为，此时子类不能自动转换成为父类的接口。父类的public和protected都被子类修改成为private可见性。 什么是多态 多态性的定义：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行效果。有两种类型的多态性： 编译时的多态 。编译时的多态是通过重载来实现的。对于非虚的成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现何种操作。 运行时的多态 。运行时的多态是指直到系统运行时，才根据实际情况决定实现何种操作。C++中，运行时的多态 虚函数的实现 虚函数是通过 虚函数表 来实现的。一个类中含有虚函数，则系统会为这个类分配一个指针成员指向一张虚函数表(vtbl)，表中每一项指向一个虚函数的地址，实现上就是一个函数指针的数组。 虚函数是为了允许用基类的指针来调用子类的这个函数 当一个成员函数被声明为虚函数后，其派生类的同名函数都自动成为虚函数，派生类的该虚函数，可以不加virtual 在构造函数中，虚拟机制机制不会发生作用。 多重继承 优点：对象可以调用多个基类中的接口。 缺点：容易出现继承向上的二义性。 为什么要引入抽象基类和纯虚函数 纯虚函数在基类中是没有定义的，必须在子类中加以实现，很想Java中的接口。如果一个基类中含有一个或多个纯虚函数，那么它就属于抽象基类，不能被实例化。 引入抽象基类和纯虚函数的原因： 为了方便使用多态特性 抽象基类不能被实例化，它定义的纯虚函数相当于接口，能把派生类的共同行为提取出来。 虚函数与纯虚函数的区别 类里如果生命了虚函数，这个函数是实现的，哪怕是空实现，作用是为了能让这个函数在它的子类里覆盖。纯虚函数只是一个接口，是个函数的声明 虚函数在子类里可以不重载，但纯虚函数必须在子类中实现。 带纯虚函数的类叫做抽象基类，不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。 指针形参与引用形参的区别 函数的形参可以是指针，此时将复制实参指针。被复制的指针只影响对指针的赋值。如果函数形参是非const类型的，则函数可以通过指针实现赋值，修改指针所指向对象的值。 指针形参是指函数的参数是指针，它不会像引用形参那样通过函数调用影响实参的值，但是调用后它会修改实参的独享。 STL容器分类 STL序列容器： vector string deque list STL关联容器 set multiset map multimap STL适配容器 stack queue priority_queue 函数模板 函数模板技术定义了参数化的非成员函数，这使得程序能够使用不同的参数类型调用相同的函数。而至于使用何种类型，则是由编译器确定并从模板中生成相应类型的代码。编译器确定了模板函数的实际类型参数，称之为模板的实例化。 类模板类模板描述了能够管理其他数据类型的通用数据类型。类模板技术通常用于建立包含其他类型的容器类。 STL如何实现vector vector支持随机访问，内部使用动态数组的方式实现。当进行insert或者push_back等增加元素的操作时，如果此时动态数组的内存不够用，就要动态地重新分配，一般是当前大小的两倍，然后吧原数组的内容拷贝过去。 vector的size()和capacity()是不同的，前者表示数组中元素的多少，后者表示数组有多大的容量。 vector的内部使用allocator类进行内存管理，程序员不需要自己操作内存。 vector中vector::size_type 十个unsigned int类型成员。无符号的整数是大于等于0的，循环条件应该使用i &gt; 0作为循环条件，i为0时结束循环 list和vector的区别 vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好地支持随机存取（使用[]操作符访问其中的元素）。当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。 list是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。如果需要大量的插入和删除，而不关心随机存取，则应使用list。 适配器stack和queue的使用12stack&lt;int,vector&lt;int&gt;&gt; s;queue&lt;int, vector&lt;int&gt;&gt; q; queue是先进先出的，入队（调用push）是对队尾进行操作，由于q使用vector作为其序列容器，因此实际调用的是vector的push_back成员函数。而出队(调用pop)是对队首进行操作，此时q需要调用的是vector的pop_front成员函数，而vector没有这个函数 map的用法1234567891011121314map&lt;int, string&gt; mapstring;mapstring.insert(pair&lt;int, string&gt;(1, "one"));mapstring[1] = "one one";mapstring.erase(2);map&lt;int, string&gt;::iterator it = mapstring.find(2);if(f != mapstring.end())&#123; mapstring.erase(f);&#125;map&lt;int, string&gt;::iterator it = mapstring.begin();while(it != mapstring.end())&#123; cout&lt;&lt;(*it).first &lt;&lt; (*it).second&#125; STL中map内部是如何实现的 标准的STL关联容器(包括set，map以及multiset和map)内部结构都是一个平航二叉树，平衡二叉树包括 AVL-tree RB-tree AA-tree STL的底层机制都是以红黑树完成的。红黑树是一个独立容器，但并不给外界使用。平均和最坏情况下的插入、删除、查找时间都是O(lgn) 红黑树的属性 节点为红色或者黑色 所有叶子节点都是空节点，并且为黑色 如果父节点是红色的，那么两个子节点都是黑色的 节点到其子孙节点的每条简单路径上都包含相同数目的黑色节点 根节点是黑色的 map和hashmap的区别 底层数据结构不同，map是红黑树，hashmap是哈希表 map的优点在于元素可以自动按照键值排序,而hashmap的优点在于它的各项操作的平均时间复杂度接近常数]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
